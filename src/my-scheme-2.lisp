(in-package #:my-scheme-2)

(defparameter *var-lst* `((,(intern "+") (lambda (x y) (+ x y)))
						  (,(intern "-") (lambda (x y) (- x y)))
						  (,(intern "*") (lambda (x y) (* x y)))
						  (,(intern "/") (lambda (x y) (/ x y)))))

(defvar *temp-var-lst*
  '())

(defun string->string-one (text)
  (mapcar #'(lambda (x) (coerce `(,x) 'string)) (concatenate 'list text)))

(defun search-lparen-pos-lst (node-lst)
  (let ((lparen-pos-lst '())
		(pos 0))
	(dolist (n node-lst)
	  (cond ((string= n "(")
			 (setq lparen-pos-lst (append lparen-pos-lst `(,pos)))))
	  (incf pos))
	lparen-pos-lst))

(defun zip (a b)
  (mapcar #'(lambda (x y) `(,x ,y)) a b))

(defun nth-range (begin end lst)
  (when (not (and (<= begin (length lst))
				  (>= (length lst) end)))
	(error "invalid begin or end."))
  (reverse (nthcdr (- (length lst) (1+ end)) (reverse (nthcdr begin lst)))))

(defun range-replace (begin end old-lst new-lst)
  (let ((pos 0)
		(result '()))
	(dolist (old old-lst)
	  (cond
		((= begin pos)
		 (setq result (append result new-lst)))
		((and (<= begin pos)
			  (>= end pos)))
		(t (setq result (append result `(,old)))))
	  (incf pos))
	result))

(defun paren-pos-pair-lst-sort (lparen-pos-lst node-lst)
  (mapcar #'(lambda (x)
			  (let ((lparen 0)
					(pos 0)
					(result -1))
				(dolist (n (nthcdr (1+ x) node-lst))
				  (when (< result 0)
					(cond ((string= n ")")
						   (if (zerop lparen)
							   (setq result (+ x pos))
							   (decf lparen)))
						  ((string= n "(")
						   (incf lparen))))
				  (incf pos))
				result))
		  lparen-pos-lst))

(defun lexer (text)
  (let ((str-list (string->string-one text))
		(node-lst '())
		(variable-tmp ""))
	(labels ((clear-vt-and-add-nlst ()
			   (setq node-lst (append node-lst `(,variable-tmp)))
			   (setq variable-tmp "")))
	  (dolist (str str-list)
		(cond ((string= "(" str)
			   (if (< 0 (length variable-tmp))
				   (clear-vt-and-add-nlst))
			   (setq node-lst (append node-lst `(,str))))
			  ((string= ")" str)
			   (if (< 0 (length variable-tmp))
				   (clear-vt-and-add-nlst))
			   (setq node-lst (append node-lst `(,str))))
			  ((string= " " str)
			   (if (< 0 (length variable-tmp))
				   (clear-vt-and-add-nlst)))
			  (t (setq variable-tmp (concatenate 'string variable-tmp str))))))
	(values node-lst (search-lparen-pos-lst node-lst))))

(defun type-convert (str)
  (cond ((ppcre:scan "\"" str)
		 (ppcre:regex-replace-all "\"" str ""))
		((ppcre:scan "^[0-9]+$" str)
		 (parse-integer str))
		(t (intern str))))

(defun eval-formula (lst)
  (eval (mapcar #'type-convert lst)))

(defun semantic-analysis (n-lst)
  (let ((node-lst n-lst))
	(labels ((f ()
			   (let ((pop (car node-lst)))
				 (setq node-lst (cdr node-lst))
				 (cond ((zerop (length node-lst))
						nil)
					   ((string= "(" pop)
						(let ((result (remove nil (loop
													 for x in node-lst
													 when (and (not (zerop (length (cdr node-lst))))
															   (not (string= (car node-lst) ")")))
													 collect (f)))))
						  (setq node-lst (cdr node-lst))
						  result)
						)
					   ((string= pop ")")
						(error "unexpected )"))
					   (t
						(type-convert pop))))))
	  (f))))

(defun eq-symbolp (a b)
  (and (symbolp a) (symbolp b) (eq a b)))

(defun deep-subst (new old node)
  (cond ((equal old node)
		 new)
		((or (not (listp node)) (null node)) node)
		(t (cons (deep-subst new old (car node))
				 (deep-subst new old (cdr node))))))

(defun my-eval (sem-lst &optional (lambdap nil))
  (cond ((find sem-lst *var-lst* :key #'car)
		 (cadr (find sem-lst *var-lst* :key #'car)))
		((not (listp sem-lst))
		 sem-lst)
		((and (not lambdap) (eq-symbolp (car sem-lst) (intern "quote")))
		 (nth 1 sem-lst))
		((and (not lambdap) (eq-symbolp (car sem-lst) (intern "if")))
		 (my-eval (if (my-eval (nth 1 sem-lst))
					  (nth 2 sem-lst)
					  (nth 3 sem-lst))))
		((and (not lambdap) (eq-symbolp (car sem-lst) (intern "set!")))
		 (push `(,(nth 1 sem-lst) ,(my-eval (nth 2 sem-lst))) *var-lst*)
		 (setq *var-lst* (remove-duplicates *var-lst* :key #'car)))
		((and (not lambdap) (eq-symbolp (car sem-lst) (intern "define")))
		 (push `(,(nth 1 sem-lst) ,(my-eval (nth 2 sem-lst))) *var-lst*)
		 (setq *var-lst* (remove-duplicates *var-lst* :key #'car)))
		((eq-symbolp (car sem-lst) (intern "lambda"))
		 (let* ((var-sym-pairs
				(zip (nth 1 sem-lst) (mapcar #'(lambda (x) (gensym))
											 (mylib:range 0 (length (nth 1 sem-lst))))))
				(replace-func #'(lambda (subst-func lst)
								  (reduce #'(lambda (res x)
											  (funcall subst-func (nth 1 x) (car x) res))
										  var-sym-pairs
										  :initial-value lst))))
		   `(lambda ,(funcall replace-func #'subst (nth 1 sem-lst))
			  ,(my-eval (funcall replace-func #'deep-subst (nth 2 sem-lst)) t))))
		((and (not lambdap) (eq-symbolp (car sem-lst) (intern "begin")))
		 (loop
			for x in (cdr sem-lst)
			do (my-eval x)))
		(lambdap (let ((exps (mapcar #'(lambda (x) (my-eval x)) sem-lst)))
				   `(,(car exps) ,@(cdr exps))))
		(t (let ((exps (mapcar #'(lambda (x) (my-eval x)) sem-lst)))
			 (eval `(,(car exps) ,@(cdr exps)))))))

(defun repl ()
  (format t ">> ")
  (let ((input (read-line)))
	(when (not (string= input "q"))
	  (print (my-eval (semantic-analysis (lexer input))))
	  (format t "~%")
	  (repl))
	))
