(in-package #:my-scheme-2)

(defparameter *var-lst* `(("+" (lambda (x y) (+ x y)))
						  ("-" (lambda (x y) (- x y)))
						  ("*" (lambda (x y) (* x y)))
						  ("/" (lambda (x y) (/ x y)))
						  ("<" (lambda (x y) (< x y)))
						  (">" (lambda (x y) (> x y)))
						  ("=" (lambda (x y) (= x y)))
						  ("nil" nil)
						  ("t" t)))

(defun string->string-one (text)
  (mapcar #'(lambda (x) (coerce `(,x) 'string)) (concatenate 'list text)))

(defun search-lparen-pos-lst (node-lst)
  (let ((lparen-pos-lst '())
		(pos 0))
	(dolist (n node-lst)
	  (cond ((string= n "(")
			 (setq lparen-pos-lst (append lparen-pos-lst `(,pos)))))
	  (incf pos))
	lparen-pos-lst))

(defun zip (a b)
  (mapcar #'(lambda (x y) `(,x ,y)) a b))

(defun nth-range (begin end lst)
  (when (not (and (<= begin (length lst))
				  (>= (length lst) end)))
	(error "invalid begin or end."))
  (reverse (nthcdr (- (length lst) (1+ end)) (reverse (nthcdr begin lst)))))

(defun range-replace (begin end old-lst new-lst)
  (let ((pos 0)
		(result '()))
	(dolist (old old-lst)
	  (cond
		((= begin pos)
		 (setq result (append result new-lst)))
		((and (<= begin pos)
			  (>= end pos)))
		(t (setq result (append result `(,old)))))
	  (incf pos))
	result))

(defun paren-pos-pair-lst-sort (lparen-pos-lst node-lst)
  (mapcar #'(lambda (x)
			  (let ((lparen 0)
					(pos 0)
					(result -1))
				(dolist (n (nthcdr (1+ x) node-lst))
				  (when (< result 0)
					(cond ((string= n ")")
						   (if (zerop lparen)
							   (setq result (+ x pos))
							   (decf lparen)))
						  ((string= n "(")
						   (incf lparen))))
				  (incf pos))
				result))
		  lparen-pos-lst))

(defun lexer (text)
  (let ((str-list (string->string-one text))
		(node-lst '())
		(variable-tmp ""))
	(labels ((clear-vt-and-add-nlst ()
			   (setq node-lst (append node-lst `(,variable-tmp)))
			   (setq variable-tmp "")))
	  (dolist (str str-list)
		(cond ((string= "(" str)
			   (if (< 0 (length variable-tmp))
				   (clear-vt-and-add-nlst))
			   (setq node-lst (append node-lst `(,str))))
			  ((string= ")" str)
			   (if (< 0 (length variable-tmp))
				   (clear-vt-and-add-nlst))
			   (setq node-lst (append node-lst `(,str))))
			  ((string= " " str)
			   (if (< 0 (length variable-tmp))
				   (clear-vt-and-add-nlst)))
			  (t (setq variable-tmp (concatenate 'string variable-tmp str))))))
	(values node-lst (search-lparen-pos-lst node-lst))))

(defun type-convert (str)
  (cond ((ppcre:scan "\"" str)
		 (ppcre:regex-replace-all "\"" str ""))
		((ppcre:scan "^[0-9]+$" str)
		 (parse-integer str))
		(t str)))

(defun eval-formula (lst)
  (eval (mapcar #'type-convert lst)))

(defun semantic-analysis (n-lst)
  (let ((node-lst n-lst))
	(labels ((f ()
			   (let ((pop (car node-lst)))
				 (setq node-lst (cdr node-lst))
				 (cond ((zerop (length node-lst))
						nil)
					   ((string= "(" pop)
						(let ((result (remove nil (loop
													 for x in node-lst
													 when (and (not (zerop (length (cdr node-lst))))
															   (not (string= (car node-lst) ")")))
													 collect (f)))))
						  (setq node-lst (cdr node-lst))
						  result)
						)
					   ((string= pop ")")
						(error "unexpected )"))
					   (t
						(type-convert pop))))))
	  (f))))

(defun stringp-string= (a b)
  (and (stringp a) (stringp b) (string= a b)))

(defun deep-subst (new old node)
  (cond ((equal old node)
		 new)
		((or (not (listp node)) (null node)) node)
		(t (cons (deep-subst new old (car node))
				 (deep-subst new old (cdr node))))))

(defun my-eval (sem-lst &optional (lambdap nil))
  (cond ((and (stringp sem-lst) (find sem-lst *var-lst* :key #'car :test #'string=))
		 (cadr (find sem-lst *var-lst* :key #'car :test #'string=)))
		((not (listp sem-lst))
		 sem-lst)
		((and (not lambdap) (stringp-string= (car sem-lst) "quote"))
		 (nth 1 sem-lst))
		((and (not lambdap) (stringp-string= (car sem-lst) "if"))
		 (my-eval (if (my-eval (nth 1 sem-lst))
					  (my-eval (nth 2 sem-lst))
					  (my-eval (nth 3 sem-lst)))))
		((and (not lambdap) (stringp-string= (car sem-lst) "set!"))
		 (push `(,(nth 1 sem-lst) ,(my-eval (nth 2 sem-lst))) *var-lst*)
		 (setq *var-lst* (remove-duplicates *var-lst* :key #'car :test #'string=)))
		((and (not lambdap) (stringp-string= (car sem-lst) "def"))
		 (push `(,(nth 1 sem-lst) ,(my-eval (nth 2 sem-lst))) *var-lst*)
		 (setq *var-lst* (remove-duplicates *var-lst* :key #'car)))
		((and (not lambdap) (stringp-string= (car sem-lst) "define"))
		 (let ((name-and-params (nth 1 sem-lst))
			   (body (nthcdr 2 sem-lst)))
		   (push `(,(car name-and-params)
					,(my-eval `("lambda" ,(nthcdr 1 name-and-params)
										 ,@body)))
				 *var-lst*)
		   (setq *var-lst* (remove-duplicates *var-lst* :key #'car))))
		((stringp-string= (car sem-lst) "lambda")
		 (let* ((var-sym-pairs
				(zip (nth 1 sem-lst) (mapcar #'(lambda (x) (gensym))
											 (mylib:range 0 (length (nth 1 sem-lst))))))
				(replace-func #'(lambda (subst-func lst)
								  (reduce #'(lambda (res x)
											  (funcall subst-func (nth 1 x) (car x) res))
										  var-sym-pairs
										  :initial-value lst))))
		   `(lambda ,(funcall replace-func #'subst (nth 1 sem-lst))
			  ,(my-eval (funcall replace-func #'deep-subst (nth 2 sem-lst)) t))))
		((and (not lambdap) (stringp-string= (car sem-lst) "begin"))
		 (loop
			for x in (cdr sem-lst)
			do (my-eval x)))
		(lambdap (let ((exps (mapcar #'(lambda (x) (my-eval x)) sem-lst)))
				   `(,(car exps) ,@(cdr exps))))
		(t (let ((exps (mapcar #'(lambda (x) (my-eval x)) sem-lst)))
			 (eval `(,(car exps) ,@(cdr exps)))))))

(defun repl ()
  (format t ">> ")
  (let ((input (read-line)))
	(when (not (string= input "q"))
	  (print (my-eval (semantic-analysis (lexer input))))
	  (format t "~%")
	  (repl))
	))

;;; 引用元: https://stackoverrun.com/ja/q/179294
(defun my-command-line ()
  (or
   #+CLISP *args*
   #+SBCL *posix-argv*
   #+LISPWORKS system:*line-arguments-list*
   #+CMU extensions:*command-line-words*
   nil))

(defun s-formula-split (str)
  (let ((result '())
		(current "")
		(lparen-cnt 0)
		(str-lst (string->string-one str)))
	(loop for x in str-lst
	   do (progn

			;; (print current)
			;; (print result)
			;; (print lparen-cnt)
			(cond ((string= "(" x)
				   (incf lparen-cnt))
				  ((string= ")" x)
				   (decf lparen-cnt)))
			(cond ((and (string= ")" x)
						(zerop lparen-cnt)
						(not (string= "" current)))
				   (setq current (format nil "~A~A" current x))
				   (setq result (append result `(,current)))
				   (setq current ""))
				  (t (setq current (format nil "~A~A" current x))))))
	(when (and (zerop lparen-cnt) (not (string= "" current)))
	  (setq result (append result `(,current))))
	result))

(defun read-file (args)
  (let ((param-one (car args)))
	(when (not param-one)
	  (error "Not Input File Path."))
	(let ((file-contents (format nil "~{~A~}" (mylib:read-file-to-list param-one))))
	  (let ((formulas (s-formula-split file-contents)))
		(loop for x in formulas
		   do (format t "~A~%" (my-eval (semantic-analysis (lexer x)))))))))
