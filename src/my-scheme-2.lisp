(in-package #:my-scheme-2)

(defvar *var-lst* '(("+" (lambda (x y) (+ x y)))
					("-" (lambda (x y) (- x y)))
					("*" (lambda (x y) (* x y)))
					("/" (lambda (x y) (/ x y)))
					("cons" (lambda (x y) (cons x y)))))

(defun string->string-one (text)
  (mapcar #'(lambda (x) (coerce `(,x) 'string)) (concatenate 'list text)))

(defun search-lparen-pos-lst (node-lst)
  (let ((lparen-pos-lst '())
		(pos 0))
	(dolist (n node-lst)
	  (cond ((string= n "(")
			 (setq lparen-pos-lst (append lparen-pos-lst `(,pos)))))
	  (incf pos))
	lparen-pos-lst))

(defun zip (pair-lst)
  (mapcar #'(lambda (x y) `(,x ,y))
		  (car pair-lst)
		  (nth 1 pair-lst)))

(defun nth-range (begin end lst)
  (when (not (and (<= begin (length lst))
				  (>= (length lst) end)))
	(error "invalid begin or end."))
  (reverse (nthcdr (- (length lst) (1+ end)) (reverse (nthcdr begin lst)))))

(defun range-replace (begin end old-lst new-lst)
  (let ((pos 0)
		(result '()))
	(dolist (old old-lst)
	  (cond
		((= begin pos)
		 (setq result (append result new-lst)))
		((and (<= begin pos)
			  (>= end pos)))
		(t (setq result (append result `(,old)))))
	  (incf pos))
	result))

(defun paren-pos-pair-lst-sort (lparen-pos-lst node-lst)
  (mapcar #'(lambda (x)
			  (let ((lparen 0)
					(pos 0)
					(result -1))
				(dolist (n (nthcdr (1+ x) node-lst))
				  (when (< result 0)
					(cond ((string= n ")")
						   (if (zerop lparen)
							   (setq result (+ x pos))
							   (decf lparen)))
						  ((string= n "(")
						   (incf lparen))))
				  (incf pos))
				result))
		  lparen-pos-lst))

(defun parser (text)
  (multiple-value-bind (node-lst lparen-pos-lst)
	  (lexer text)
	(let ((result `()))
	  (dolist (paren-pos-pair (zip `(,lparen-pos-lst
	  								 ,(paren-pos-pair-lst-sort lparen-pos-lst node-lst))))
	  	(setq result (append result
	  						 `(((,(car paren-pos-pair) . ,(car (reverse paren-pos-pair)))
								,(nth-range (car paren-pos-pair)
	  										(1+ (car (reverse paren-pos-pair)))
	  										node-lst))))))
	  result)))

(defun lexer (text)
  (let ((str-list (string->string-one text))
		(node-lst '())
		(variable-tmp "")
		(str-tmp "")
		(str-flg nil)
		(quote-tmp "")
		(quote-flg))
	(labels ((clear-vt-and-add-nlst ()
			   (setq node-lst (append node-lst `(,variable-tmp)))
			   (setq variable-tmp "")))
	  (dolist (str str-list)
		(cond ((and str-flg (string= "\"" str))
			   (setq node-lst (append node-lst `(,(concatenate 'string str-tmp "\""))))
			   (setq str-tmp "")
			   (setq str-flg nil))
			  (str-flg
			   (setq str-tmp (concatenate 'string str-tmp str)))
			  ((and quote-flg (string= "@" str))
			   (setq node-lst (append node-lst `(,(concatenate 'string quote-tmp "@"))))
			   (setq quote-tmp "")
			   (setq quote-flg nil))
			  (quote-flg
			   (setq quote-tmp (concatenate 'string quote-tmp str)))
			  (t (cond ((and (string= "@" str) (not str-flg))
						(setq quote-tmp (concatenate 'string quote-tmp "@"))
						(setq quote-flg t))
					   ((and (string= "\"" str) (not quote-flg))
						(setq str-tmp (concatenate 'string str-tmp "\""))
						(setq str-flg t))
					   ((string= "(" str)
						(if (< 0 (length variable-tmp))
							(clear-vt-and-add-nlst))
						(setq node-lst (append node-lst `(,str))))
					   ((string= ")" str)
						(if (< 0 (length variable-tmp))
							(clear-vt-and-add-nlst))
						(setq node-lst (append node-lst `(,str))))
					   ((string= " " str)
						(if (< 0 (length variable-tmp))
							(clear-vt-and-add-nlst)))
					   (t (setq variable-tmp (concatenate 'string variable-tmp str))))))))
	(values node-lst (search-lparen-pos-lst node-lst))))

(defun type-convert (str)
  (cond
	;; quote formula
	((ppcre:scan "^@.*@$" str)
	 str)
	((ppcre:scan "^\".*\"$" str)
	 (ppcre:regex-replace-all "\"" str ""))
	((ppcre:scan "^[0-9]+$" str)
	 (parse-integer str))
	(t (cadr (find str *var-lst* :key #'car :test #'string=)))))

(defun eval-formula (lst)
  (let ((key (car lst)))
	(cond ((string= key "def")
		   (setq *var-lst* (remove-duplicates
							(append *var-lst* `((,(cadr lst) ,@(mapcar #'type-convert (cddr lst)))))
							:key #'car
							:test #'string=)))
		  ;; ???????
		  ((string= key "lambda")
		   lst)
		  (t (eval (mapcar #'type-convert lst))))))

(defun numbered-lst-range-replace (begin end old-lst new-lst)
  (let ((result '()))
	(dolist (old old-lst)
	  (cond
		((integerp old)
		 (setq result (append result `(,old))))
		((and (integerp (car old)) (= begin (car old)))
		 (setq result (append result new-lst)))
		((and (integerp (car old))
			  (<= begin (car old))
			  (>= end (car old))))
		(t (setq result (append result `(,old))))))
	result))

(defun eval-inter (parsed)
  (cond ((>= 1 (count "(" (cadr (car parsed)) :test #'string=))
		 (eval-formula (remove ")"
							   (remove "(" (cadr (car parsed))
									   :test #'string=)
							   :test #'string=)))
		(t (let* ((leafs (remove-if #'(lambda (x)
										(< 1 (count "(" (nth 1 x) :test #'string=)))
									parsed))
				  (leafs-remove->paren (mapcar #'(lambda (x)
												   `(,(car x) ,(remove ")"
																	   (remove "(" (nth 1 x)
																			   :test #'string=)
																	   :test #'string=)))
											   leafs))
				  (leafs-evaled (mapcar #'(lambda (x) `(,(car x) ,(eval-formula (nth 1 x))))
										leafs-remove->paren))
				  (numbered-origin (mapcar #'(lambda (x y) `(,x ,y))
										   (mylib:range 0 (length (cadr (car parsed))))
										   (cadr (car parsed))))
				  (result numbered-origin))
			 (dolist (pos-value leafs-evaled)
			   (setq result (numbered-lst-range-replace
							 (car (car pos-value))
							 (1+ (cdr (car pos-value)))
							 result
							 `(,(car (cdr pos-value))))))
			 (let ((result-str (string-trim '(#\Space #\newline #\tab)
											(format nil "~{ ~A~}"
													(mapcar #'(lambda (x) (if (or (integerp x) (stringp x))
																			  x
																			  (cadr x)))
															result)))))
			   (eval-inter (parser result-str)))))))

(defun my-eval-read ()
  (let ((parsed (parser (read))))
	(eval-inter parsed)))

(defun my-eval (text)
  (cond ((type-convert text)
		 (type-convert text))
		(t (labels ((rangep (pair val)
					  (and (<= (car pair) val)
						   (>= (cdr pair) val))))
			 (let* ((parsed (parser text))
					;; quiteのものは全て取得
					(quote-lst (remove-if-not #'(lambda (x) (string= "quote" (nth 1 (nth 1 x))))
											  parsed))
					;; quoteの中のquoteは取り除く
					(quote-removed-lst (remove-if #'(lambda (x)
													  (find-if #'(lambda (y)
																   (and (not (equal (car y) (car x)))
																		(rangep (car y) (car x))))
															   quote-lst))
												  quote-lst))
					(first-numbered-parsed `(,(car (car parsed))
											  ,(mapcar #'(lambda (y z) `(,y ,z))
													   (mylib:range 0 (length (cadr (car parsed))))
													   (cadr (car parsed)))))
					;; quote対象の文字列を置き換える
					(replaced-parsed (cadr first-numbered-parsed)))
			   (dolist (quote-removed quote-removed-lst)
	  			 (setq replaced-parsed
	  				   (numbered-lst-range-replace
						(caar quote-removed)
						(cdr (car quote-removed))
	  					replaced-parsed
	  					`(,(string-trim '(#\Space #\newline #\tab)
	  									(format nil "@~{ ~A~}@" (reverse (cdr (reverse (cddr (cadr quote-removed)))))))))))
			   ;; (print (parser (string-trim '(#\Space #\newline #\tab)
			   ;; 								   (format nil "~{ ~A~}"
			   ;; 										   (mapcar #'(lambda (x) (if (or (integerp x) (stringp x))
			   ;; 																	 x
			   ;; 																	 (cadr x)))
			   ;; 												   replaced-parsed)))))
			   (eval-inter (parser (string-trim '(#\Space #\newline #\tab)
	  											(format nil "~{ ~A~}"
	  													(mapcar #'(lambda (x) (if (or (integerp x) (stringp x))
	  																			  x
	  																			  (cadr x)))
	  															replaced-parsed)))))
			   )))))
